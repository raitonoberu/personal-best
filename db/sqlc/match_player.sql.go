// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: match_player.sql

package sqlc

import (
	"context"
	"strings"
)

const createMatchPlayer = `-- name: CreateMatchPlayer :exec
INSERT INTO
    match_players (match_id, player_id, position, team)
VALUES
    (?, ?, ?, ?)
`

type CreateMatchPlayerParams struct {
	MatchID  int64
	PlayerID int64
	Position string
	Team     bool
}

func (q *Queries) CreateMatchPlayer(ctx context.Context, arg CreateMatchPlayerParams) error {
	_, err := q.db.ExecContext(ctx, createMatchPlayer,
		arg.MatchID,
		arg.PlayerID,
		arg.Position,
		arg.Team,
	)
	return err
}

const deleteMatchPlayers = `-- name: DeleteMatchPlayers :exec
DELETE FROM
    match_players
WHERE
    match_id = ?
`

func (q *Queries) DeleteMatchPlayers(ctx context.Context, matchID int64) error {
	_, err := q.db.ExecContext(ctx, deleteMatchPlayers, matchID)
	return err
}

const listMatchPlayers = `-- name: ListMatchPlayers :many
SELECT
    match_id, player_id, position, team
FROM
    match_players
WHERE
    match_id = ?
`

func (q *Queries) ListMatchPlayers(ctx context.Context, matchID int64) ([]MatchPlayer, error) {
	rows, err := q.db.QueryContext(ctx, listMatchPlayers, matchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MatchPlayer
	for rows.Next() {
		var i MatchPlayer
		if err := rows.Scan(
			&i.MatchID,
			&i.PlayerID,
			&i.Position,
			&i.Team,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMatchPlayersBatch = `-- name: ListMatchPlayersBatch :many
SELECT
    match_id, player_id, position, team
FROM
    match_players
WHERE
    match_id IN (/*SLICE:match_ids*/?)
`

func (q *Queries) ListMatchPlayersBatch(ctx context.Context, matchIds []int64) ([]MatchPlayer, error) {
	query := listMatchPlayersBatch
	var queryParams []interface{}
	if len(matchIds) > 0 {
		for _, v := range matchIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:match_ids*/?", strings.Repeat(",?", len(matchIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:match_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MatchPlayer
	for rows.Next() {
		var i MatchPlayer
		if err := rows.Scan(
			&i.MatchID,
			&i.PlayerID,
			&i.Position,
			&i.Team,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMatchPlayersWithPlayersBatch = `-- name: ListMatchPlayersWithPlayersBatch :many
SELECT
    match_players.match_id, match_players.player_id, match_players.position, match_players.team,
    users.id, users.role_id, users.email, users.password, users.first_name, users.last_name, users.middle_name, users.created_at,
    players.user_id, players.birth_date, players.is_male, players.phone, players.telegram, players.preparation, players.position
FROM
    match_players
JOIN
    users ON match_players.player_id == users.id
JOIN
    players ON match_players.player_id == players.user_id
WHERE
    match_id IN (/*SLICE:match_ids*/?)
`

type ListMatchPlayersWithPlayersBatchRow struct {
	MatchPlayer MatchPlayer
	User        User
	Player      Player
}

func (q *Queries) ListMatchPlayersWithPlayersBatch(ctx context.Context, matchIds []int64) ([]ListMatchPlayersWithPlayersBatchRow, error) {
	query := listMatchPlayersWithPlayersBatch
	var queryParams []interface{}
	if len(matchIds) > 0 {
		for _, v := range matchIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:match_ids*/?", strings.Repeat(",?", len(matchIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:match_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMatchPlayersWithPlayersBatchRow
	for rows.Next() {
		var i ListMatchPlayersWithPlayersBatchRow
		if err := rows.Scan(
			&i.MatchPlayer.MatchID,
			&i.MatchPlayer.PlayerID,
			&i.MatchPlayer.Position,
			&i.MatchPlayer.Team,
			&i.User.ID,
			&i.User.RoleID,
			&i.User.Email,
			&i.User.Password,
			&i.User.FirstName,
			&i.User.LastName,
			&i.User.MiddleName,
			&i.User.CreatedAt,
			&i.Player.UserID,
			&i.Player.BirthDate,
			&i.Player.IsMale,
			&i.Player.Phone,
			&i.Player.Telegram,
			&i.Player.Preparation,
			&i.Player.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
