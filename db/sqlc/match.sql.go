// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: match.sql

package sqlc

import (
	"context"
	"time"
)

const createMatch = `-- name: CreateMatch :execlastid
INSERT INTO
    matches (competition_id, start_time)
VALUES
    (?, ?)
`

type CreateMatchParams struct {
	CompetitionID int64
	StartTime     time.Time
}

func (q *Queries) CreateMatch(ctx context.Context, arg CreateMatchParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createMatch, arg.CompetitionID, arg.StartTime)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const deleteMatches = `-- name: DeleteMatches :exec
DELETE FROM
    matches
WHERE
    competition_id = ?
`

func (q *Queries) DeleteMatches(ctx context.Context, competitionID int64) error {
	_, err := q.db.ExecContext(ctx, deleteMatches, competitionID)
	return err
}

const getLastMatch = `-- name: GetLastMatch :one
SELECT
    id, competition_id, start_time, left_score, right_score
FROM
    matches
WHERE
    competition_id = ? AND left_score IS NOT NULL AND right_score IS NOT NULL
ORDER BY
    start_time DESC
LIMIT 1
`

func (q *Queries) GetLastMatch(ctx context.Context, competitionID int64) (Match, error) {
	row := q.db.QueryRowContext(ctx, getLastMatch, competitionID)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.CompetitionID,
		&i.StartTime,
		&i.LeftScore,
		&i.RightScore,
	)
	return i, err
}

const getMatch = `-- name: GetMatch :one
SELECT
    id, competition_id, start_time, left_score, right_score
FROM
    matches
WHERE
    id = ?
`

func (q *Queries) GetMatch(ctx context.Context, id int64) (Match, error) {
	row := q.db.QueryRowContext(ctx, getMatch, id)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.CompetitionID,
		&i.StartTime,
		&i.LeftScore,
		&i.RightScore,
	)
	return i, err
}

const getNextMatch = `-- name: GetNextMatch :one
SELECT
    id, competition_id, start_time, left_score, right_score
FROM
    matches
WHERE
    competition_id = ? AND left_score IS NULL AND right_score IS NULL
ORDER BY
    start_time
LIMIT 1
`

func (q *Queries) GetNextMatch(ctx context.Context, competitionID int64) (Match, error) {
	row := q.db.QueryRowContext(ctx, getNextMatch, competitionID)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.CompetitionID,
		&i.StartTime,
		&i.LeftScore,
		&i.RightScore,
	)
	return i, err
}

const listAllMatches = `-- name: ListAllMatches :many
SELECT
    id, competition_id, start_time, left_score, right_score
FROM
    matches
WHERE
    competition_id = ?
ORDER BY
    start_time
`

func (q *Queries) ListAllMatches(ctx context.Context, competitionID int64) ([]Match, error) {
	rows, err := q.db.QueryContext(ctx, listAllMatches, competitionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.ID,
			&i.CompetitionID,
			&i.StartTime,
			&i.LeftScore,
			&i.RightScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMatches = `-- name: ListMatches :many
SELECT
    matches.id, matches.competition_id, matches.start_time, matches.left_score, matches.right_score,
    COUNT() OVER() as total
FROM
    matches
WHERE
    competition_id = ?
ORDER BY
    start_time
LIMIT
    ? OFFSET ?
`

type ListMatchesParams struct {
	CompetitionID int64
	Limit         int64
	Offset        int64
}

type ListMatchesRow struct {
	Match Match
	Total int64
}

func (q *Queries) ListMatches(ctx context.Context, arg ListMatchesParams) ([]ListMatchesRow, error) {
	rows, err := q.db.QueryContext(ctx, listMatches, arg.CompetitionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMatchesRow
	for rows.Next() {
		var i ListMatchesRow
		if err := rows.Scan(
			&i.Match.ID,
			&i.Match.CompetitionID,
			&i.Match.StartTime,
			&i.Match.LeftScore,
			&i.Match.RightScore,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMatchesByPlayer = `-- name: ListMatchesByPlayer :many
SELECT
    matches.id,
    matches.competition_id,
    match_players.team,
    competitions.name,
    matches.start_time,
    matches.left_score,
    matches.right_score,
    COUNT() OVER() as total
FROM
    match_players
JOIN
    matches ON match_players.match_id = matches.id
JOIN
    competitions ON competitions.id = matches.competition_id
WHERE
    match_players.player_id = ?
ORDER BY
    start_time DESC
LIMIT
    ? OFFSET ?
`

type ListMatchesByPlayerParams struct {
	PlayerID int64
	Limit    int64
	Offset   int64
}

type ListMatchesByPlayerRow struct {
	ID            int64
	CompetitionID int64
	Team          bool
	Name          string
	StartTime     time.Time
	LeftScore     *int64
	RightScore    *int64
	Total         int64
}

func (q *Queries) ListMatchesByPlayer(ctx context.Context, arg ListMatchesByPlayerParams) ([]ListMatchesByPlayerRow, error) {
	rows, err := q.db.QueryContext(ctx, listMatchesByPlayer, arg.PlayerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMatchesByPlayerRow
	for rows.Next() {
		var i ListMatchesByPlayerRow
		if err := rows.Scan(
			&i.ID,
			&i.CompetitionID,
			&i.Team,
			&i.Name,
			&i.StartTime,
			&i.LeftScore,
			&i.RightScore,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMatchScore = `-- name: UpdateMatchScore :exec
UPDATE
    matches
SET
    left_score = ?, right_score = ?
WHERE
    id = ?
`

type UpdateMatchScoreParams struct {
	LeftScore  *int64
	RightScore *int64
	ID         int64
}

func (q *Queries) UpdateMatchScore(ctx context.Context, arg UpdateMatchScoreParams) error {
	_, err := q.db.ExecContext(ctx, updateMatchScore, arg.LeftScore, arg.RightScore, arg.ID)
	return err
}
